# water-jug-challenge

## Overview 
Build an application that solves the Water Jug Riddle for dynamic inputs (X, Y, Z). The simulation should have a UI (if SPA) to display state changes for each state for each jug (Empty, Full or Partially Full). You have an X-gallon and a Y-gallon jug that you can fill from a lake. (Assume lake has unlimited amount of water.) By using only an X-gallon and Y-gallon jug (no third jug), measure Z gallons of water.

The original problem statement can be found [here](./docs/original_problem_statement.pdf).

## Goals
1. Measure Z gallons of water in the most efficient way.
2. Build a UI where a user can enter any input for X, Y, Z and see the solution.
3. If no solution, display “No Solution”.

## Limitations
• Actions allowed: Fill, Empty, Transfer.
## Deliverables
The application source code should be on Github and a link should be provided. If this is not an option, a public link to the application source code or a zip archive is also acceptable.
Example:
Bucket x: 2
Bucket Y: 10
Amount wanted Z: 4

### Best Solution
![Best Solution](./docs/best_solution.png)
### Worst Solution
![Worst Solution](./docs/worst_solution.png)

## Algorithm
The algorithm is designed to solve this problem using a systematic approach. It explores all possible states, generated by the permitted actions, until it finds a solution or determines that no solution exists.

### Key Components
1. State Representation: Each state is represented as a pair (x, y), where x and y denote the current amounts of water in the respective jugs.
2. Actions: The algorithm simulates three types of actions:
* Filling a Jug: Filling either jug to its full capacity.
* Emptying a Jug: Emptying all the water from either jug.
* Transferring Water: Moving water from one jug to the other until either the source jug is empty or the destination jug is full.
3. Breadth-First Search (BFS): The algorithm employs BFS, a methodical strategy that explores all states level by level. It ensures that if a solution exists, it will be found in the least number of steps.
4. Goal Check: The algorithm continually checks whether the target amount of water has been measured in either jug.
5. Path Reconstruction: When the target state is found, the algorithm traces back the steps taken to reach this state, providing a clear sequence of actions.

### Solvability Check
Before executing the BFS, the algorithm performs a preliminary check to determine if the problem is solvable:
* The target amount must not exceed the capacities of both jugs.
* The target amount must be a multiple of the greatest common divisor (GCD) of the two jug capacities.

### Process Flow
1. Initialization: The algorithm begins with both jugs empty, represented as (0, 0).
2. Exploration: It then systematically explores all possible states through the permitted actions, tracking each state and the action taken to reach it.
3. Goal Identification: The algorithm checks each new state to see if the target amount has been achieved.
4. Termination: The process continues until either the target state is found (yielding a solution) or all possible states have been explored without success (indicating no solution is possible).

### Example
For example, with jug capacities X = 4 gallons, Y = 3 gallons, and a target of Z = 2 gallons, the algorithm will explore a sequence of states such as filling Jug Y, transferring to Jug X, and so on, until it reaches a state where one of the jugs contains exactly 2 gallons.

### Conclusion
This algorithm is a comprehensive solution to the Water Jug problem, capable of finding the most efficient sequence of actions to achieve the desired measurement or determining that no solution is possible. It's a demonstration of applying systematic exploration and state-space search techniques to solve a classic problem in computer science and logic.

## Running the app
To run the app you must have docker and docker-compose installed. Run the following command to start the full application stack:

```console 
make run
```
or

```console 
docker compose -f ./docker-compose.yml up -d --build
```

The app will start in the default http port (80) and you can access it using [this url](http://localhost:8080)

To stop the app run it:

```console 
make stop
```
or

```console 
docker compose -f ./docker-compose.yml down
```